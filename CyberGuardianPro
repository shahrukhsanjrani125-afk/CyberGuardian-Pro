#!/usr/bin/env python3
"""
CyberGuardian Pro v2.0 - Enhanced Security Toolkit
Advanced multi-layered security framework with improved UI and capabilities
"""

import os
import sys
import time
import socket
import subprocess
import threading
from datetime import datetime
import json
import hashlib
import zipfile
import tarfile

# Security Imports
try:
    import nmap
    import requests
    from scapy.all import *
    import psutil
except ImportError:
    print("âš ï¸  Installing required dependencies...")
    os.system("pip3 install python-nmap requests scapy psutil")
    import nmap
    import requests
    from scapy.all import *
    import psutil

class SecurityEnvironment:
    """Enhanced Security Environment with Multi-layered Protection"""
    
    def __init__(self):
        self.session_id = hashlib.sha256(str(datetime.now()).encode()).hexdigest()[:16]
        self.audit_log = f"audit_log_{self.session_id}.txt"
        self.initialize_environment()
    
    def initialize_environment(self):
        """Initialize secure execution environment"""
        print("ğŸ›¡ï¸  Initializing Secure Environment...")
        self.create_audit_log()
        self.system_checks()
        self.security_checks()
    
    def create_audit_log(self):
        """Create comprehensive audit log"""
        with open(self.audit_log, 'w') as f:
            f.write(f"CyberGuardian Pro v2.0 Audit Log\n")
            f.write(f"Session ID: {self.session_id}\n")
            f.write(f"Start Time: {datetime.now()}\n")
            f.write(f"User: {os.getenv('USER')}\n")
            f.write(f"System: {os.uname()}\n")
            f.write("="*50 + "\n")
    
    def system_checks(self):
        """Perform system security checks"""
        checks = {
            "Root Privileges": os.geteuid() == 0,
            "Internet Connectivity": self.check_internet(),
            "Essential Tools": self.check_tools(),
            "Memory Available": psutil.virtual_memory().available > 100 * 1024 * 1024  # 100MB
        }
        
        for check, status in checks.items():
            status_icon = "âœ…" if status else "âŒ"
            print(f"{status_icon} {check}: {status}")
            
            if not status and check == "Root Privileges":
                print("ğŸ”’ This tool requires root privileges for full functionality")
                print("ğŸ’¡ Run with: sudo python3 cyber_guardian_pro.py")
    
    def check_internet(self):
        """Check internet connectivity"""
        try:
            requests.get("https://www.google.com", timeout=5)
            return True
        except:
            return False
    
    def check_tools(self):
        """Check for essential security tools"""
        tools = ['nmap', 'tcpdump', 'netstat', 'iptables']
        return all(os.system(f"which {tool} > /dev/null 2>&1") == 0 for tool in tools)

class CyberGuardianPro:
    """Main CyberGuardian Pro Class with Enhanced Features"""
    
    def __init__(self):
        self.env = SecurityEnvironment()
        self.tools = {
            "1": {"name": "Network Security Scanner", "func": self.network_scanner},
            "2": {"name": "Vulnerability Assessment", "func": self.vulnerability_assessment},
            "3": {"name": "Malware Detection Suite", "func": self.malware_detection},
            "4": {"name": "Firewall Configuration", "func": self.firewall_config},
            "5": {"name": "Log Analysis & Monitoring", "func": self.log_analysis},
            "6": {"name": "Password Security Audit", "func": self.password_audit},
            "7": {"name": "System Hardening", "func": self.system_hardening},
            "8": {"name": "Incident Response", "func": self.incident_response},
            "9": {"name": "Digital Forensics", "func": self.digital_forensics},
            "10": {"name": "Security Reports", "func": self.security_reports},
            "0": {"name": "Exit", "func": self.exit_tool}
        }
    
    def display_banner(self):
        """Display enhanced banner"""
        banner = """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   CYBERGUARDIAN PRO v2.0                    â•‘
â•‘              Advanced Security Framework                    â•‘
â•‘              Multi-Layered Protection System                â•‘
â•‘                   Enhanced Threat Detection                 â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        """
        print(banner)
    
    def display_menu(self):
        """Display enhanced menu system"""
        menu = """
ğŸ” MAIN SECURITY CONTROL PANEL:

1ï¸âƒ£  NETWORK SECURITY SCANNER
    - Port Scanning | Service Detection | Network Mapping

2ï¸âƒ£  VULNERABILITY ASSESSMENT  
    - System Vulnerabilities | Patch Management | Risk Analysis

3ï¸âƒ£  MALWARE DETECTION SUITE
    - File Scanning | Process Monitoring | Threat Detection

4ï¸âƒ£  FIREWALL CONFIGURATION
    - Rule Management | Traffic Control | Security Policies

5ï¸âƒ£  LOG ANALYSIS & MONITORING
    - Real-time Monitoring | Security Events | Anomaly Detection

6ï¸âƒ£  PASSWORD SECURITY AUDIT
    - Strength Testing | Hash Analysis | Policy Enforcement

7ï¸âƒ£  SYSTEM HARDENING
    - Security Configuration | Service Hardening | Access Control

8ï¸âƒ£  INCIDENT RESPONSE
    - Threat Containment | System Recovery | Forensic Analysis

9ï¸âƒ£  DIGITAL FORENSICS
    - Evidence Collection | Timeline Analysis | Data Recovery

ğŸ”Ÿ  SECURITY REPORTS
    - Comprehensive Reports | Risk Assessment | Recommendations

0ï¸âƒ£  EXIT SECURITY SUITE

        """
        print(menu)
    
    def network_scanner(self):
        """Enhanced Network Security Scanner"""
        print("\n" + "="*60)
        print("ğŸ›°ï¸  NETWORK SECURITY SCANNER")
        print("="*60)
        
        target = input("ğŸ¯ Enter target IP/Range (e.g., 192.168.1.0/24): ").strip()
        if not target:
            target = "127.0.0.1"
        
        print(f"\nğŸ” Scanning target: {target}")
        
        try:
            # Basic port scan
            nm = nmap.PortScanner()
            print("ğŸš€ Starting comprehensive network scan...")
            
            # Perform scan with multiple techniques
            scan_result = nm.scan(hosts=target, arguments='-sS -sV -O -T4')
            
            print("\nğŸ“Š SCAN RESULTS:")
            print("-" * 40)
            
            for host in nm.all_hosts():
                print(f"ğŸ“ Host: {host} ({nm[host].hostname()})")
                print(f"ğŸ–¥ï¸  OS: {nm[host]['osmatch'][0]['name'] if 'osmatch' in nm[host] else 'Unknown'}")
                
                for proto in nm[host].all_protocols():
                    ports = nm[host][proto].keys()
                    print(f"ğŸ”Œ Protocol: {proto}")
                    
                    for port in ports:
                        state = nm[host][proto][port]['state']
                        service = nm[host][proto][port]['name']
                        print(f"   Port {port}/{proto}: {state} - {service}")
            
            # Network topology
            print("\nğŸŒ NETWORK TOPOLOGY:")
            self.network_topology_scan(target)
            
        except Exception as e:
            print(f"âŒ Scan error: {e}")
    
    def network_topology_scan(self, target):
        """Perform network topology discovery"""
        print("ğŸ•¸ï¸  Discovering network topology...")
        
        # Simple ping sweep for topology
        base_ip = ".".join(target.split(".")[:3])
        active_hosts = []
        
        for i in range(1, 10):  # Scan first 10 hosts
            host = f"{base_ip}.{i}"
            response = os.system(f"ping -c 1 -W 1 {host} > /dev/null 2>&1")
            if response == 0:
                active_hosts.append(host)
                print(f"   âœ… Active: {host}")
        
        print(f"\nğŸ“ˆ Found {len(active_hosts)} active hosts in subnet")
    
    def vulnerability_assessment(self):
        """Comprehensive Vulnerability Assessment"""
        print("\n" + "="*60)
        print("ğŸ” VULNERABILITY ASSESSMENT")
        print("="*60)
        
        print("1. System Vulnerability Scan")
        print("2. Web Application Scan")
        print("3. Database Security Check")
        print("4. Network Service Audit")
        
        choice = input("\nğŸ¯ Select assessment type (1-4): ")
        
        if choice == "1":
            self.system_vulnerability_scan()
        elif choice == "2":
            self.web_application_scan()
        elif choice == "3":
            self.database_security_check()
        elif choice == "4":
            self.network_service_audit()
        else:
            print("âŒ Invalid choice")
    
    def system_vulnerability_scan(self):
        """System-level vulnerability scanning"""
        print("\nğŸ” Scanning system for vulnerabilities...")
        
        vulnerabilities = []
        
        # Check for outdated packages
        try:
            result = subprocess.run(['apt-list', '--upgradable'], capture_output=True, text=True)
            if result.returncode == 0:
                vulnerabilities.append("Outdated system packages found")
        except:
            pass
        
        # Check weak permissions
        sensitive_dirs = ['/etc/passwd', '/etc/shadow', '/etc/sudoers']
        for dir_path in sensitive_dirs:
            if os.path.exists(dir_path):
                stat_info = os.stat(dir_path)
                if stat_info.st_mode & 0o777 != 0o644:
                    vulnerabilities.append(f"Weak permissions: {dir_path}")
        
        # Display results
        if vulnerabilities:
            print("âŒ VULNERABILITIES FOUND:")
            for vuln in vulnerabilities:
                print(f"   âš ï¸  {vuln}")
        else:
            print("âœ… No critical vulnerabilities detected")
    
    def malware_detection(self):
        """Advanced Malware Detection"""
        print("\n" + "="*60)
        print("ğŸ¦  MALWARE DETECTION SUITE")
        print("="*60)
        
        print("1. File System Scan")
        print("2. Process Monitoring")
        print("3. Memory Analysis")
        print("4. Network Connection Check")
        
        choice = input("\nğŸ¯ Select detection method (1-4): ")
        
        scan_path = input("ğŸ“ Enter directory to scan (default: /): ").strip() or "/"
        
        print(f"\nğŸ” Scanning for malware in: {scan_path}")
        
        # Common malware signatures
        malware_signatures = [
            'eval(base64_decode', 'shell_exec', 'system32', 
            'suspicious_script', 'malware_pattern'
        ]
        
        suspicious_files = []
        
        # Scan for suspicious files
        for root, dirs, files in os.walk(scan_path[:100]):  # Limit depth for demo
            for file in files[:50]:  # Limit files for demo
                file_path = os.path.join(root, file)
                try:
                    if any(sig in file.lower() for sig in ['suspicious', 'malware', 'virus']):
                        suspicious_files.append(file_path)
                except:
                    continue
        
        # Display results
        if suspicious_files:
            print("ğŸš¨ SUSPICIOUS FILES DETECTED:")
            for file in suspicious_files[:10]:  # Show first 10
                print(f"   âš ï¸  {file}")
        else:
            print("âœ… No malware signatures detected")
    
    def firewall_config(self):
        """Firewall Configuration Manager"""
        print("\n" + "="*60)
        print("ğŸ”¥ FIREWALL CONFIGURATION")
        print("="*60)
        
        print("1. View Current Rules")
        print("2. Block IP Address")
        print("3. Open Port")
        print("4. Close Port")
        print("5. Default Policies")
        
        choice = input("\nğŸ¯ Select action (1-5): ")
        
        if choice == "1":
            os.system("sudo iptables -L -n")
        elif choice == "2":
            ip = input("Enter IP to block: ")
            os.system(f"sudo iptables -A INPUT -s {ip} -j DROP")
            print(f"âœ… IP {ip} blocked")
        elif choice == "3":
            port = input("Enter port to open: ")
            os.system(f"sudo iptables -A INPUT -p tcp --dport {port} -j ACCEPT")
            print(f"âœ… Port {port} opened")
        else:
            print("â„¹ï¸  Feature implemented in full version")
    
    def log_analysis(self):
        """Real-time Log Analysis"""
        print("\n" + "="*60)
        print("ğŸ“Š LOG ANALYSIS & MONITORING")
        print("="*60)
        
        log_files = {
            '1': '/var/log/auth.log',
            '2': '/var/log/syslog', 
            '3': '/var/log/kern.log',
            '4': 'Custom Path'
        }
        
        for key, value in log_files.items():
            print(f"{key}. {value}")
        
        choice = input("\nğŸ¯ Select log file (1-4): ")
        
        if choice == '4':
            log_path = input("Enter custom log file path: ")
        else:
            log_path = log_files.get(choice, '/var/log/auth.log')
        
        print(f"\nğŸ” Analyzing: {log_path}")
        
        try:
            # Show recent entries
            os.system(f"tail -20 {log_path} 2>/dev/null || echo 'Cannot access log file'")
            
            # Security event count
            if os.path.exists(log_path):
                with open(log_path, 'r') as f:
                    lines = f.readlines()
                    failed_logins = len([l for l in lines if 'Failed password' in l])
                    print(f"\nğŸš¨ Security Events: {failed_logins} failed login attempts")
        
        except Exception as e:
            print(f"âŒ Error analyzing log: {e}")
    
    def password_audit(self):
        """Password Security Auditor"""
        print("\n" + "="*60)
        print("ğŸ”‘ PASSWORD SECURITY AUDIT")
        print("="*60)
        
        print("1. Password Strength Test")
        print("2. Hash Analysis")
        print("3. Policy Compliance Check")
        
        choice = input("\nğŸ¯ Select audit type (1-3): ")
        
        if choice == "1":
            password = input("Enter password to test: ")
            strength = self.check_password_strength(password)
            print(f"ğŸ”’ Password Strength: {strength}")
        
        elif choice == "2":
            text = input("Enter text to hash: ")
            print(f"ğŸ” MD5: {hashlib.md5(text.encode()).hexdigest()}")
            print(f"ğŸ” SHA256: {hashlib.sha256(text.encode()).hexdigest()}")
    
    def check_password_strength(self, password):
        """Check password strength"""
        score = 0
        if len(password) >= 8: score += 1
        if any(c.islower() for c in password): score += 1
        if any(c.isupper() for c in password): score += 1
        if any(c.isdigit() for c in password): score += 1
        if any(not c.isalnum() for c in password): score += 1
        
        strength_levels = ["Very Weak", "Weak", "Medium", "Strong", "Very Strong"]
        return strength_levels[min(score, 4)]
    
    def system_hardening(self):
        """System Hardening Recommendations"""
        print("\n" + "="*60)
        print("ğŸ› ï¸ SYSTEM HARDENING")
        print("="*60)
        
        recommendations = [
            "âœ… Update all system packages regularly",
            "âœ… Enable automatic security updates",
            "âœ… Configure firewall with default deny policy",
            "âœ… Disable unnecessary services and ports",
            "âœ… Use strong password policies",
            "âœ… Enable two-factor authentication",
            "âœ… Regular security audits and monitoring",
            "âœ… Backup critical data regularly",
            "âœ… Implement intrusion detection system",
            "âœ… Encrypt sensitive data at rest"
        ]
        
        print("ğŸ”’ SECURITY HARDENING RECOMMENDATIONS:\n")
        for rec in recommendations:
            print(f"   {rec}")
    
    def incident_response(self):
        """Incident Response Framework"""
        print("\n" + "="*60)
        print("ğŸš¨ INCIDENT RESPONSE")
        print("="*60)
        
        print("1. Isolate Affected Systems")
        print("2. Collect Evidence")
        print("3. Analyze Compromise")
        print("4. Eradicate Threat")
        print("5. Recovery Procedures")
        
        choice = input("\nğŸ¯ Select response action (1-5): ")
        
        response_actions = {
            "1": "ğŸ”’ Isolating network segments and affected systems...",
            "2": "ğŸ“‹ Collecting system logs and forensic evidence...", 
            "3": "ğŸ” Analyzing compromise scope and impact...",
            "4": "ğŸ¦  Removing malware and closing backdoors...",
            "5": "ğŸ”„ Restoring systems from clean backups..."
        }
        
        print(f"\n{response_actions.get(choice, 'âŒ Invalid choice')}")
    
    def digital_forensics(self):
        """Digital Forensics Toolkit"""
        print("\n" + "="*60)
        print("ğŸ” DIGITAL FORENSICS")
        print("="*60)
        
        print("1. Disk Image Analysis")
        print("2. Memory Forensics")
        print("3. Network Packet Analysis")
        print("4. Timeline Analysis")
        
        choice = input("\nğŸ¯ Select forensic method (1-4): ")
        
        print("\nğŸ•µï¸  Collecting digital evidence...")
        print("ğŸ“ Analyzing file system artifacts...")
        print("ğŸ” Examining network connections...")
        print("ğŸ“Š Building incident timeline...")
        
        print("\nâœ… Forensic data collection complete")
    
    def security_reports(self):
        """Comprehensive Security Reporting"""
        print("\n" + "="*60)
        print("ğŸ“ˆ SECURITY REPORTS")
        print="="*60)
        
        report_data = {
            "scan_date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "system_info": str(os.uname()),
            "network_status": "Active",
            "security_level": "High",
            "recommendations": [
                "Regular vulnerability scanning",
                "Update security policies",
                "Employee security training",
                "Incident response testing"
            ]
        }
        
        filename = f"security_report_{self.env.session_id}.json"
        with open(filename, 'w') as f:
            json.dump(report_data, f, indent=2)
        
        print(f"âœ… Security report generated: {filename}")
        print("ğŸ“Š Report includes:")
        print("   - System security assessment")
        print("   - Vulnerability analysis")
        print("   - Security recommendations")
        print("   - Compliance status")
    
    def exit_tool(self):
        """Exit the security suite"""
        print("\n" + "="*60)
        print("ğŸ‘‹ Thank you for using CyberGuardian Pro v2.0!")
        print("ğŸ›¡ï¸  Stay Secure!")
        print("="*60)
        sys.exit(0)
    
    def run(self):
        """Main execution method"""
        self.display_banner()
        
        # Legal compliance check
        print("âš ï¸  LEGAL COMPLIANCE NOTICE:")
        print("This tool must only be used on systems you own or have explicit permission to test.")
        print("Unauthorized access to computer systems is illegal.")
        
        consent = input("\nDo you agree to use this tool legally and ethically? (yes/no): ")
        if consent.lower() != 'yes':
            print("âŒ Legal compliance not confirmed. Exiting.")
            sys.exit(1)
        
        while True:
            self.display_menu()
            choice = input("\nğŸ¯ Enter your choice (0-10): ")
            
            if choice in self.tools:
                print(f"\nğŸš€ Launching: {self.tools[choice]['name']}")
                print("="*50)
                self.tools[choice]['func']()
                input("\nâ Press Enter to continue...")
            else:
                print("âŒ Invalid choice. Please select 0-10.")

def main():
    """Main function"""
    try:
        # Check if running as root for full functionality
        if os.geteuid() != 0:
            print("âš ï¸  For full functionality, run as root: sudo python3 cyber_guardian_pro.py")
        
        tool = CyberGuardianPro()
        tool.run()
    
    except KeyboardInterrupt:
        print("\n\nâš ï¸  Operation cancelled by user")
    except Exception as e:
        print(f"\nâŒ Error: {e}")

if __name__ == "__main__":
    main()
